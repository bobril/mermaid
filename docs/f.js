(function(e){"use strict";var n=__bbb.rb;var d=__bbb.db;var r=__bbb.lb;var t=__bbb.nb;__bbb.mb;var a=__bbb.Lb;var o=__bbb.Mb;var _=__bbb.Nb;var s=__bbb.Ob;var i=__bbb.Pb;var g=__bbb.Qb;var l=__bbb.Rb;var c=__bbb.Sb;var h=__bbb.Tb;var u=__bbb.Ub;var p=__bbb.Vb;var A=__bbb.Wb;var f=__bbb.Xb;var I=__bbb.Yb;var b=__bbb.Zb;var v=__bbb.$b;var k=__bbb._b;function w(e){var r={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:V(e),edges:F(e)};n(e.graph())||(r.value=d(e.graph()));return r}function V(e){return r(e.nodes(),function(d){var r=e.node(d);var t=e.parent(d);var a={v:d};n(r)||(a.value=r);n(t)||(a.parent=t);return a})}function F(e){return r(e.edges(),function(d){var r=e.edge(d);var t={v:d.v,w:d.w};n(d.name)||(t.name=d.name);n(r)||(t.value=r);return t})}var m=new Map;var W=new Map;var C=new Map;var y=a(()=>{W.clear();C.clear();m.clear()},"clear");var N=a((e,n)=>{const d=W.get(n)||[];o.trace("In isDescendant",n," ",e," = ",d.includes(e));return d.includes(e)},"isDescendant");var D=a((e,n)=>{const d=W.get(n)||[];o.info("Descendants of ",n," is ",d);o.info("Edge is ",e);if(e.v===n||e.w===n){return!1}if(!d){o.debug("Tilt, ",n,",not in descendants");return!1}return d.includes(e.v)||N(e.v,n)||N(e.w,n)||d.includes(e.w)},"edgeInCluster");var E=a((e,n,d,r)=>{o.warn("Copying children of ",e,"root",r,"data",n.node(e),r);const t=n.children(e)||[];e!==r&&t.push(e);o.warn("Copying (nodes) clusterId",e,"nodes",t);t.forEach(t=>{if(n.children(t).length>0){E(t,n,d,r)}else{let a=n.node(t);o.info("cp ",t," to ",r," with parent ",e);d.setNode(t,a);if(r!==n.parent(t)){o.warn("Setting parent",t,n.parent(t));d.setParent(t,n.parent(t))}if(e!==r&&t!==e){o.debug("Setting parent",t,e);d.setParent(t,e)}else{o.info("In copy ",e,"root",r,"data",n.node(e),r);o.debug("Not Setting parent for node=",t,"cluster!==rootId",e!==r,"node!==clusterId",t!==e)}let _=n.edges(t);o.debug("Copying Edges",_);_.forEach(t=>{o.info("Edge",t);const a=n.edge(t.v,t.w,t.name);o.info("Edge data",a,r);try{if(D(t,r)){o.info("Copying as ",t.v,t.w,a,t.name);d.setEdge(t.v,t.w,a,t.name);o.info("newGraph edges ",d.edges(),d.edge(d.edges()[0]))}else{o.info("Skipping copy of edge ",t.v,"--\x3e",t.w," rootId: ",r," clusterId:",e)}}catch(e){o.error(e)}})}o.debug("Removing node",t);n.removeNode(t)})},"copy");var X=a((e,n)=>{const d=n.children(e);let r=[...d];for(const t of d){C.set(t,e);r=[...r,...X(t,n)]}return r},"extractDescendants");var G=a((e,n,d)=>{const r=e.edges().filter(e=>e.v===n||e.w===n);const t=e.edges().filter(e=>e.v===d||e.w===d);const a=r.map(e=>({v:e.v===n?d:e.v,w:e.w===n?n:e.w}));const o=t.map(e=>({v:e.v,w:e.w}));const _=a.filter(e=>o.some(n=>e.v===n.v&&e.w===n.w));return _},"findCommonEdges");var S=a((e,n,d)=>{const r=n.children(e);o.trace("Searching children of id ",e,r);if(r.length<1){return e}let t;for(const e of r){let r=S(e,n,d),a=G(n,d,r);if(r){if(a.length>0){t=r}else{return r}}}return t},"findNonClusterChild");var R=a(e=>{if(!m.has(e)){return e}if(!m.get(e).externalConnections){return e}if(m.has(e)){return m.get(e).id}return e},"getAnchorId");var x=a((e,n)=>{if(!e||n>10){o.debug("Opting out, no graph ");return}else{o.debug("Opting in, graph ")}e.nodes().forEach(function(n){const d=e.children(n);if(d.length>0){o.warn("Cluster identified",n," Replacement id in edges: ",S(n,e,n));W.set(n,X(n,e));m.set(n,{id:S(n,e,n),clusterData:e.node(n)})}});e.nodes().forEach(function(n){const d=e.children(n);const r=e.edges();if(d.length>0){o.debug("Cluster identified",n,W);r.forEach(e=>{const d=N(e.v,n);const r=N(e.w,n);if(d^r){o.warn("Edge: ",e," leaves cluster ",n);o.warn("Descendants of XXX ",n,": ",W.get(n));m.get(n).externalConnections=!0}})}else{o.debug("Not a cluster ",n,W)}});for(let n of m.keys()){let d=m.get(n).id,r=e.parent(d);r!==n&&m.has(r)&&!m.get(r).externalConnections&&(m.get(n).id=r)}e.edges().forEach(function(n){const d=e.edge(n);o.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n));o.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let r=n.v;let t=n.w;o.warn("Fix XXX",m,"ids:",n.v,n.w,"Translating: ",m.get(n.v)," --- ",m.get(n.w));if(m.get(n.v)||m.get(n.w)){o.warn("Fixing and trying - removing XXX",n.v,n.w,n.name);r=R(n.v);t=R(n.w);e.removeEdge(n.v,n.w,n.name);if(r!==n.v){let t=e.parent(r);m.get(t).externalConnections=!0;d.fromCluster=n.v}if(t!==n.w){let r=e.parent(t);m.get(r).externalConnections=!0;d.toCluster=n.w}o.warn("Fix Replacing with XXX",r,t,n.name);e.setEdge(r,t,d,n.name)}});o.warn("Adjusted Graph",w(e));M(e,0);o.trace(m)},"adjustClustersAndEdges");var M=a((e,n)=>{var d,r;o.warn("extractor - ",n,w(e),e.children("D"));if(n>10){o.error("Bailing out");return}let a=e.nodes();let _=!1;for(const n of a){let d=e.children(n);_=_||d.length>0}if(!_){o.debug("Done, no node has children",e.nodes());return}o.debug("Nodes = ",a,n);for(const _ of a){o.debug("Extracting node",_,m,m.has(_)&&!m.get(_).externalConnections,!e.parent(_),e.node(_),e.children("D")," Depth ",n);if(!m.has(_)){o.debug("Not a cluster",_,n)}else if(!m.get(_).externalConnections&&e.children(_)&&e.children(_).length>0){o.warn("Cluster without external connections, without a parent and with children",_,n);let a=e.graph(),s=a.rankdir==="TB"?"LR":"TB";if((r=(d=m.get(_))===null||d===void 0?void 0:d.clusterData)===null||r===void 0?void 0:r.dir){s=m.get(_).clusterData.dir;o.warn("Fixing dir",m.get(_).clusterData.dir,s)}let i=new t({multigraph:!0,compound:!0}).setGraph({rankdir:s,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});o.warn("Old graph before copy",w(e));E(_,e,i,_);e.setNode(_,{clusterNode:!0,id:_,clusterData:m.get(_).clusterData,label:m.get(_).label,graph:i});o.warn("New graph after copy node: (",_,")",w(i));o.debug("Old graph after copy",w(e))}else{o.warn("Cluster ** ",_," **not meeting the criteria !externalConnections:",!m.get(_).externalConnections," no parent: ",!e.parent(_)," children ",e.children(_)&&e.children(_).length>0,e.children("D"),n);o.debug(m)}}a=e.nodes();o.warn("New list of nodes",a);for(const d of a){let r=e.node(d);o.warn(" Now next level",d,r);(r===null||r===void 0?void 0:r.clusterNode)&&M(r.graph,n+1)}},"extractor");var L=a((e,n)=>{if(n.length===0){return[]}let d=Object.assign([],n);n.forEach(n=>{const r=e.children(n);const t=L(e,r);d=[...d,...t]});return d},"sorter");var T=a(e=>L(e,e.children()),"sortNodesByHierarchy");var P=a(async(e,n,d,r,t,f)=>{o.warn("Graph in recursive render:XAX",w(n),t);const I=n.graph().rankdir;o.trace("Dir in recursive render - dir:",I);const b=e.insert("g").attr("class","root");if(!n.nodes()){o.info("No nodes found for",n)}else{o.info("Recursive render XXX",n.nodes())}n.edges().length>0&&o.info("Recursive edges",n.edge(n.edges()[0]));const v=b.insert("g").attr("class","clusters");const k=b.insert("g").attr("class","edgePaths");const V=b.insert("g").attr("class","edgeLabels");const F=b.insert("g").attr("class","nodes");await Promise.all(n.nodes().map(async function(e){const a=n.node(e);if(t!==void 0){let d=JSON.parse(JSON.stringify(t.clusterData));o.trace("Setting data for parent cluster XXX\n Node.id = ",e,"\n data=",d.height,"\nParent cluster",t.height);n.setNode(t.id,d);if(!n.parent(e)){o.trace("Setting parent",e,t.id);n.setParent(e,t.id,d)}}o.info("(Insert) Node XXX"+e+": "+JSON.stringify(n.node(e)));if(a===null||a===void 0?void 0:a.clusterNode){o.info("Cluster identified XBX",e,a.width,n.node(e));let{ranksep:t,nodesep:i}=n.graph();a.graph.setGraph({...a.graph.graph(),ranksep:t+25,nodesep:i});let g=await P(F,a.graph,d,r,n.node(e),f),l=g.elem;_(a,l);a.diff=g.diff||0;o.info("New compound node after recursive render XAX",e,"width",a.width,"height",a.height);s(l,a)}else{if(n.children(e).length>0){o.trace("Cluster - the non recursive path XBX",e,a.id,a,a.width,"Graph:",n);o.trace(S(a.id,n));m.set(a.id,{id:S(a.id,n),node:a})}else{o.trace("Node - the non recursive path XAX",e,F,n.node(e),I);await i(F,n.node(e),{config:f,dir:I})}}}));const W=a(async()=>{const e=n.edges().map(async function(e){const d=n.edge(e.v,e.w,e.name);o.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e));o.info("Edge "+e.v+" -> "+e.w+": ",e," ",JSON.stringify(n.edge(e)));o.info("Fix",m,"ids:",e.v,e.w,"Translating: ",m.get(e.v),m.get(e.w));await g(V,d)});await Promise.all(e)},"processEdges");await W();o.info("Graph before layout:",JSON.stringify(w(n)));o.info("############################################# XXX");o.info("###                Layout                 ### XXX");o.info("############################################# XXX");l(n);o.info("Graph after layout:",JSON.stringify(w(n)));let C=0;let{subGraphTitleTotalMargin:y}=c(f);await Promise.all(T(n).map(async function(e){var d;const r=n.node(e);o.info("Position XBX => "+e+": ("+r.x,","+r.y,") width: ",r.width," height: ",r.height);if(r===null||r===void 0?void 0:r.clusterNode){r.y+=y;o.info("A tainted cluster node XBX1",e,r.id,r.width,r.height,r.x,r.y,n.parent(e));m.get(r.id).node=r;h(r)}else{if(n.children(e).length>0){o.info("A pure cluster node XBX1",e,r.id,r.x,r.y,r.width,r.height,n.parent(e));r.height+=y;n.node(r.parentId);let t=(r===null||r===void 0?void 0:r.padding)/2||0,a=((d=r===null||r===void 0?void 0:r.labelBBox)===null||d===void 0?void 0:d.height)||0,_=a-t||0;o.debug("OffsetY",_,"labelHeight",a,"halfPadding",t);await u(v,r);m.get(r.id).node=r}else{let e=n.node(r.parentId);r.y+=y/2;o.info("A regular node XBX1 - using the padding",r.id,"parent",r.parentId,r.width,r.height,r.x,r.y,"offsetY",r.offsetY,"parent",e,e===null||e===void 0?void 0:e.offsetY,r);h(r)}}}));n.edges().forEach(function(e){const t=n.edge(e);o.info("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(t),t);t.points.forEach(e=>e.y+=y/2);const a=n.node(e.v);var _=n.node(e.w);const s=p(k,t,m,d,a,_,r);A(t,s)});n.nodes().forEach(function(e){const d=n.node(e);o.info(e,d.type,d.diff);d.isGroup&&(C=d.diff)});o.warn("Returning from recursive render XAX",b,C);return{elem:b,diff:C}},"recursiveRender");var U=a(async(e,n)=>{var d,r,a,_,s,i;const g=new t({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((d=e.config)===null||d===void 0?void 0:d.nodeSpacing)||((a=(r=e.config)===null||r===void 0?void 0:r.flowchart)===null||a===void 0?void 0:a.nodeSpacing)||e.nodeSpacing,ranksep:((_=e.config)===null||_===void 0?void 0:_.rankSpacing)||((i=(s=e.config)===null||s===void 0?void 0:s.flowchart)===null||i===void 0?void 0:i.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});const l=n.select("g");f(l,e.markers,e.type,e.diagramId);I();b();v();y();e.nodes.forEach(e=>{g.setNode(e.id,{...e});e.parentId&&g.setParent(e.id,e.parentId)});o.debug("Edges:",e.edges);e.edges.forEach(e=>{if(e.start===e.end){let n=e.start,d=n+"---"+n+"---1",r=n+"---"+n+"---2",t=g.node(n);g.setNode(d,{domId:d,id:d,parentId:t.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10});g.setParent(d,t.parentId);g.setNode(r,{domId:r,id:r,parentId:t.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10});g.setParent(r,t.parentId);let a=structuredClone(e),o=structuredClone(e),_=structuredClone(e);a.label="";a.arrowTypeEnd="none";a.id=n+"-cyclic-special-1";o.arrowTypeStart="none";o.arrowTypeEnd="none";o.id=n+"-cyclic-special-mid";_.label="";if(t.isGroup){a.fromCluster=n;_.toCluster=n}_.id=n+"-cyclic-special-2";_.arrowTypeStart="none";g.setEdge(n,d,a,n+"-cyclic-special-0");g.setEdge(d,r,o,n+"-cyclic-special-1");g.setEdge(r,n,_,n+"-cyc<lic-special-2")}else{g.setEdge(e.start,e.end,{...e},e.id)}});o.warn("Graph at first:",JSON.stringify(w(g)));x(g);o.warn("Graph after XAX:",JSON.stringify(w(g)));const c=k();await P(l,g,e.type,e.diagramId,void 0,c)},"render");var O={render:U};__bbb.e=O}).call(this)